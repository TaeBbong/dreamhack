# Linux Exploit & Mitigation

## Part 1

### ELF 동적 디버깅

```bash
$ echo "set disassembly-flavor intel" >> ~/.gdbinit

$ ps -aux | grep process_name
$ gdb -q -p {pid}
```

gdb 명령어

```bash
(gdb) disas main
> disassembly main func
(gdb) b *0xaaaaaaaa
> breakpoint
(gdb) info break
> show breakpoint
(gdb) p $eax
> eax에 저장된 값을 출력
(gdb) x/2wx $esp
> esp 레지스터에 저장된 값이 가리키는 메모리를 word 타입으로 2개만큼
0xffff : 0x456  0x467
esp 값    저장된값 저장된값
(스택주소)
(gdb) ni
> 다음 명령어 실행
(gdb) display
> 매 실행시 인자로 전달된 값을 출력
```

> 타입
> w(word)
> s(string)
> i(instruction)

### RET Overwrite Exploit

Stack BoF 취약점이 있을때 스택에 저장된 함수의 리턴 주소를 덮는 공격

스택
Low   buf    : 함수 내 지역변수
      SFP    : 이전 스택 base(ebp)
      RET    : 함수 종료 후 다음 명령
High  param  : 함수에 전달될 인자

Buffer OverFlow를 통해 (len(buf) + len(sfp)) * 'A' + 원하는주소로 RET을 덮으면 됨

여기서 ret 명령어는 스택의 top에 저장된 값(esp에 저장된 값)으로 점프하는 명령어

=> eip에 해당 값을 전달
=> 원하는주소가 esp에 저장되어 있으므로 eip에 해당 값이 전달, 다음 명령어로 원하는주소가 실행

=> 쉘코드를 메모리 어딘가에 저장해놓고, 쉘코드가 저장된 위치 주소값을 RET에 덮으면 eip에 쉘코드 주소값이 전달, 그러면 다음 실행 명령어로 쉘코드 주소값이 전달되어 코드 실행

리눅스 쉘코드
sys_execve("/bin/sh", 0, 0)
이걸 기계어로 변환하면 쉘코드 생성
=> 아키텍처만 동일하면 똑같은 기능을 수행

```bash
$ nasm -f elf shellcode.asm
$ objdump -d shellcode.o
$ objdump --dump-section .text=shellcode.bin shellcode.o
```

이때 쉘코드를 어디에 넣을것이냐가 중요한데, 일반적으로 buffer에 넣게됨
=> 쉘코드 + 남는크기 + SFP까지 넣고, + RET에 쉘코드 시작주소, 즉 buffer의 시작주소를 넣을 것인데,
=> buffer는 지역변수라 환경에 따라 buffer의 시작주소가 달라짐
=> 따라서 절대값으로 buffer 시작주소를 넣는 것은 어려움
=> 코드 수정 필요

> 헷갈리는 이유 : 프로그램은 코드 영역의 명령어를 실행하는 것이고, 이를 실행하기 위해 스택에다가 코드 영역의 명령어의 주소를 넣어 eip로 실행하게 함. 근데 shellcode는 스택 영역에 들어가 있어 shellcode의 시작 주소는 스택 영역의 메모리 주소임.
> 와중에 또 주소값은 little endian으로 넣어줘야 함!

### NOP Sled

NOP : 아무것도 실행하지 않는 명령어
> x86 아키텍처 : 0x90

NOP + shellcode + 남는buffer + SFP로 하게 되면 딱 정확히 shellcode의 시작주소를 RET에 넣지 않아도 적당히 그 앞에 넣으면 NOP을 실행하다가 shellcode를 만나 실행하게 됨

"A" * (bufSize + len(SFP)) + NOP Sled의 중간주소 + NOP Sled + shellcode

=> buffer는 A로 다 채우고, SFP도 A로 채우고, NOP이 있을만한 적당한 주소를 넣고, 그 뒤에 NOP을 엄청 많이 넣고, shellcode를 넣으면 ret에 NOP이 있을만한 주소가 들어가고 그러면 쭉 이후가 실행되다가 shellcode가 실행

### NX bit

앞서 정리했던 헷갈리는 포인트처럼, 정상적인 프로그램과 달리 쉘코드 실행은 코드 영역의 데이터(명령어)를 실행하는게 아닌 스택 영역의 데이터(명령어)를 실행하게 됨

일반적인 프로그램은 당연히 스택 영역의 메모리를 코드 실행 용도로 쓰지 않기 때문에, 실행 권한이 필요 없다

이를 기반으로 프로그램의 공격을 어렵게 하기 위해 메모리에 쓰기 권한과 실행 권한을 동시에 부여하지 않는 NX bit가 등장!

> rwx : 읽기/쓰기/실행

이제 더이상 스택 메모리에 shellcode를 저장해서 실행 흐름을 스택으로 바꿀 수 없음

이제는 실행 권한이 있는 영역에 존재하는 코드만을 사용해야 함

이를테면 라이브러리 파일을 로드할 때 함께 불러지는 함수를 활용한다면 우회가 가능할 수 있다!(system과 같은..)

=> RTL(Return To Libc) : 리턴 주소를 라이브러리 내에 존재하는 함수의 주소로 바꿔 NX bit을 우회하는 기법

libc.so.6 라이브러리 내에는 execve, execlp, execl, execvp, system, popen과 같은 프로그램을 실행할 수 있는 다양한 함수 존재

=> 특히 system은 인자가 하나만 있으면 되어 편리함
=> system("/bin/sh")

정상함수RET
1
2
3

=>

새로운함수
1
2
3

이렇게 바꾸고 ret 명령이 실행되면

eip : 새로운 함수
esp : 1

새로운 함수가 실행되니까

정상함수RET : 새로운함수
1         : 새로운함수RET
2         : 1
3         : 2

이렇게 메모리 바뀜

따라서 익스플로잇 구조는

sizeof(buf) + sizeof(sfp) + system함수주소 + "AAAA"(system함수RET, 의미 없음) + "bin/sh" 주소

여기서 system 함수 주소와 "bin/sh" 문자열 주소가 필요함

일단 p system으로 system 함수의 주소(코드영역)를 찾고,

라이브러리 내로 범위를 잡고 "/bin/sh"을 검색하면 해당 문자열의 주소가 나옴

```bash
(gdb) p system
$1 = {<text variable, no debug info>} 0xf7e3dda0 <system>
(gdb) find 0xf7e03000, 0xf7fb3000, "/bin/sh"
0xf7f5ea0b
1 pattern found.
(gdb) x/s 0xf7f5ea0b
0xf7f5ea0b:	"/bin/sh"
```